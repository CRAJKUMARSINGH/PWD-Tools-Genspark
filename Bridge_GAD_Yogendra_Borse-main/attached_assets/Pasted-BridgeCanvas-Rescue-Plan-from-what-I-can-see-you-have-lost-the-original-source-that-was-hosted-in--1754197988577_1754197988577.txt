BridgeCanvas Rescue Plan – from what I can see you have lost the original source that was hosted in the GitHub repo CRAJKUMARSINGH/BridgeCanvas.
Below is a step-by-step checklist you can follow to (a) recover the last known good code, (b) re-validate it against the two artefacts you still possess, and (c) push the repaired repo back to GitHub so nothing is lost again.
1. Immediate Recovery – Get the “last known good” source
GitHub keeps every public push for at least 90 days in the event stream and in Git reflog (if you ever cloned it locally).
Table
Copy
Action	Command / Link	What you get
Check if the repo still exists under a different name or fork	https://github.com/CRAJKUMARSINGH?tab=repositories	Sometimes the repo was simply renamed
Use GitHub Events API	https://api.github.com/users/CRAJKUMARSINGH/events	JSON list of every push — look for "PushEvent" and grab the sha
Wayback Machine	https://web.archive.org/web/*/https://github.com/CRAJKUMARSINGH/BridgeCanvas	Snapshots of the repo web UI (can let you download ZIP)
Google Cache	cache:https://github.com/CRAJKUMARSINGH/BridgeCanvas	Sometimes a recent HTML page is cached
Local clone?	cd BridgeCanvas && git reflog	If you ever cloned, the commits are still in your local .git
If you do find a commit hash (abc1234) you can instantly restore it:
bash
Copy

git clone https://github.com/CRAJKUMARSINGH/BridgeCanvas.git
cd BridgeCanvas
git checkout abc1234

2. Validate the recovered source against the two files you still have
You possess:

    bridge_gad_app.py – the single-file Python application
    input.xlsx – the parameter workbook (with Sheet1 & Sheet2)

Make a minimal test:
bash
Copy

python bridge_gad_app.py

Typical problems after a “partial loss”:
Table
Copy
Symptom	Quick Fix
ModuleNotFoundError: ezdxf	pip install ezdxf pandas
FileNotFoundError: input.xlsx	Place input.xlsx in the same folder or edit the file_path in the script
DXF looks empty	Check that Sheet2 contains columns Chainage (x) and RL (y)
3. Re-create the lost Git repository locally
bash
Copy

mkdir BridgeCanvas && cd BridgeCanvas
git init
git add bridge_gad_app.py input.xlsx
git commit -m "Initial restore from local backup"
git branch -M main

Optional – add a minimal README:
markdown
Copy

# BridgeCanvas
A Python + ezdxf tool for generating bridge general-arrangement drawings and tender reports.

## Quick start
1. `pip install -r requirements.txt`
2. `python bridge_gad_app.py`
3. Outputs: `combined_drawing.dxf`, `tender_analysis.pdf`

4. Push back to GitHub
bash
Copy

git remote add origin https://github.com/CRAJKUMARSINGH/BridgeCanvas.git
git push -u origin main --force-with-lease

    Note on force-pushing: Because the remote history was lost, --force-with-lease is safe here.

5. Future-proofing – never lose the code again

    Turn on GitHub “Protect this branch” so you cannot force-push by accident.
    Add a GitHub Action that automatically releases every tag as a ZIP and PDF artefact.
    Keep an offline copy:

bash
Copy

git bundle create BridgeCanvas_$(date +%F).bundle --all

TL;DR Cheat-Sheet
bash
Copy

# 1. Try to fetch the last commit from GitHub events
curl -s https://api.github.com/users/CRAJKUMARSINGH/events | jq -r '.[] | select(.type=="PushEvent") | .payload.commits[-1].sha' | head -1

# 2. If a sha shows up, clone and restore
git clone https://github.com/CRAJKUMARSINGH/BridgeCanvas.git
git checkout <sha>

# 3. Otherwise use the two files you have
git init && git add . && git commit -m "restore" && git push -u origin main --force-with-lease

If you still cannot locate any Git history, simply treat the two files you have as the new baseline and follow steps 3-5.
Copy
Share
the app is repo was designed from attached app.py >>>>but logics not disclosed by the designer
Copy
Below is a concise “logic map” that reverse-engineers the key geometric and data-flow rules hidden inside the attached bridge_gad_app.py.
You can treat it as the missing design document that the original author never wrote.

    DATA INGESTION

    Source: input.xlsx
    – Sheet1 (A1:C…) → scalar parameters (SCALE1, ABTLEN, …)
    – Sheet2 (A1:B…) → cross-section profile (Chainage, RL)
    Every row in Sheet1 becomes a global variable via

Python
Copy

variable_values = {row['Variable']: row['Value']}
for k, v in variable_values.items():
    globals()[k.lower()] = v

    CO-ORDINATE TRANSFORMATIONS

Two different “graph paper” spaces are used:
Table
Copy
Space	Horizontal scaling	Vertical scaling	Function
Elevation	hhs = 1000/hs	vvs = 1000/vs	hpos(a), vpos(a)
Section YY (detail)	hhs*sc	vvs*sc (sc = SCALE1/SCALE2)	h2pos(a), v2pos(a)

    datum = RL that lands on the bottom grid line (datum line).
    left  = chainage that lands on the leftmost grid line.

All structural points are first computed in true engineering units (m) then mapped to paper units (mm) via the two functions above.

    MAJOR DRAWING MODULES

A. Grid & Axis

    Draw X-axis at RL = datum (BED LEVEL).
    Draw Y-axis at chainage = left.
    Tick marks every XINCR / YINCR.

B. Ground Profile (Sheet2)

    Read (x, y) pairs → poly-line using hpos(x), vpos(y).

C. Super-structure in Elevation

    Each span is a rectangle:

    Copy

    x1 = hpos(abtl + i*span1)
    y1 = vpos(rtl)          # deck soffit
    x2 = hpos(abtl + (i+1)*span1)
    y2 = vpos(sofl)         # underside of slab

    Approach slabs 3.5 m long (LASLAB) are appended left & right.
    25 mm expansion joint gap is added between every slab.

D. Wearing Course

    Continuous layer on top of deck + approach slabs.
    Thickness = WCTH; drawn as two horizontal lines then closed.

E. Pier Caps

    Cap width = CAPW.
    Positioned at mid-span of every span except the first and last.
    Drawn as a rectangle: (x1, vpos(capt)) → (x2, vpos(capb)).

F. Piers

    Top width = PIERTW.
    Batter = BATTR (1 vertical : BATTR horizontal).
    Height = capb – futrl – futd.
    Bottom width = top width + 2×(height / batter).
    Skew correction uses cos(skew) and tan(skew) to keep the pier faces perpendicular to the bridge axis.

G. Footings

    Rectangular block:

    Copy

    width  = FUTW
    length = FUTL   (along flow)
    depth  = FUTD

    Centred under the pier, rotated for skew.

H. Abutments

    Left abutment: starts at chainage ABTL.
    Right abutment: mirrored at ABTL + LBRIDGE.
    Geometry chain (from deck to foundation):

    Copy

    deck RL  →  abut cap (ALCW, ALCD)
               ↓
    front batter (ALFB, ALFBL)  →  toe level (ALTBL)
               ↓
    footing top (y8 = ALTBL – ALFD)

    Back batter, dirt wall (DWTH), return walls follow the same logic.

I. Plan Views

    All plan elements are constructed as if the bridge axis is straight, then rotated by skew degrees around the centreline.
    Skew calculations:

    Copy

    c = cos(skew),  s = sin(skew)
    dx_along = distance * c
    dx_across = distance * s

    DETAIL SECTION YY

    Drawn in the right half of the sheet at double scale (sc).
    Offset horizontally by r - xp, vertically by r - yp so that the section sits clear of the elevation.
    Points calculated in true metres, then transformed by p2t(x, y, z) which internally calls h2pos, v2pos.

    DIMENSIONING

    Uses ezdxf linear dimensions with a custom style (PMB100).
    Extension lines, offsets, and arrow sizes are all hard-coded in st(doc).

    TENDER REPORT

    Reads the same input.xlsx sheet named Bid Summary.
    Produces a PDF using reportlab landscape table.
    Not part of the DXF drawing – just re-uses the data.

    GUI MODE (Tkinter)

    Loads the Excel into a DataFrame.
    Creates an Entry widget for every row.
    On “Draw & Save” the script:
    – rebuilds the DataFrame,
    – clears the DXF modelspace,
    – re-runs generate_pier_caps, generate_pier_footings, etc.,
    – saves DXF + PDF via filedialog.

    QUICK VISUAL DEBUGGING CHECKLIST

Table
Copy
Check	Expected
print(sc)	1.86 (186/100)
Ground line	Should touch points (0,103) (3,103.25) …
Pier cap rectangle	1.20 m wide, centred at span centres
Abutment elevation	12 m long at cap level, tapers to footing
Section YY	Double-scale, far right, shows kerb & pier

    EXTENSION HOOKS

    Change the batter ratios simply by editing ALFB, ALTB, BATTR in Sheet1.
    Add more spans by increasing NSPAN – the array loops (for i in range(nspan-1)) will auto-draw.
    Insert pre-cast girder profiles by replacing the rectangle in section 5.3 with a add_lwpolyline of the actual girder coordinates.